{"task_id": 3275, "completion_id": 0, "solution": "class Solution:\n\n    def minimumPushes(self, word: str) -> int:\n        n = len(word)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if word[i] == word[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n        return max(dp[0][n - 1])"}
{"task_id": 3271, "completion_id": 0, "solution": ""}
{"task_id": 3276, "completion_id": 0, "solution": "class Solution:\n\n    def minimumPushes(self, word: str) -> int:\n        n = len(word)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if word[i] == word[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n        return max(dp[0])"}
{"task_id": 3310, "completion_id": 0, "solution": "class Solution:\n\n    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:\n        if x == y:\n            return [1]\n        if x == y:\n            return [1, 1]\n        if x == y:\n            return [1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]\n        if x == y:\n            return [1, 1, 1, 1]"}
{"task_id": 3263, "completion_id": 0, "solution": "class Solution:\n\n    def minimumCost(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return min(nums[0], nums[1])\n        dp = [0] * (n + 1)\n        dp[0] = nums[0]\n        dp[1] = nums[1]\n        for i in range(2, n + 1):\n            dp[i] = min(dp[i - 1], dp[i - 2] + nums[i])\n        return min(dp[-1], dp[-2])"}
{"task_id": 3291, "completion_id": 0, "solution": "class Solution:\n\n    def canSortArray(self, nums: List[int]) -> bool:\n        \"\"\"\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        if not nums:\n            return False\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] >= nums[i - 1]:\n                return True\n        return False"}
{"task_id": 3244, "completion_id": 0, "solution": "class Solution:\n\n    def minimumArrayLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums.sort()\n        res = 0\n        for i in range(n):\n            res += 1\n            if nums[i] == nums[i - 1]:\n                res += 1\n        return res"}
{"task_id": 3260, "completion_id": 0, "solution": "class Solution:\n\n    def minimumCost(self, nums: List[int], k: int, dist: int) -> int:\n        n = len(nums)\n        if k == n:\n            return 0\n        if k == 1:\n            return nums[0]\n        if k == 2:\n            return min(nums[0], nums[1])\n        if k == 3:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 4:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 5:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 6:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 7:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 8:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 9:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 10:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 11:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 12:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 13:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 14:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 15:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 16:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 17:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 18:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 19:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 20:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 21:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 22:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 23:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 24:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 25:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 26:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 27:\n            return min(nums[0], nums[1]) + nums[2]\n        if k == 28:\n            return min(nums[0], nums[1]) + nums[2]"}
{"task_id": 3242, "completion_id": 0, "solution": "class Solution:\n\n    def maxFrequencyElements(self, nums: List[int]) -> int:\n        max_freq = 0\n        max_freq_freq = 0\n        max_freq_freq_dict = {}\n        for num in nums:\n            if num in max_freq_freq:\n                max_freq_freq_dict[num] += 1\n            else:\n                max_freq_freq_dict[num] = 1\n            max_freq += 1\n        max_freq_freq_dict = max_freq_freq_dict.copy()\n        max_freq_freq_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()\n        max_freq_freq_dict_dict = max_freq_freq_dict_dict.copy()\n        max_freq_freq_dict_dict.sort()"}
{"task_id": 3245, "completion_id": 0, "solution": "class Solution:\n\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n\n        def is_beautiful(s):\n            if len(s) == 1:\n                return True\n            for i in range(len(s)):\n                if s[i] == a or s[i] == b:\n                    return False\n            return True\n\n        def is_beautiful(s):\n            if len(s) == 1:\n                return True\n            for i in range(len(s)):\n                if s[i] == a or s[i] == b:\n                    return False\n            return True\n\n        def is_beautiful(s):\n            if len(s) == 1:\n                return True\n            for i in range(len(s)):\n                if s[i] == a or s[i] == b:\n                    return False\n            return True\n        return [is_beautiful(s) for s in s]\ns = Solution()"}
{"task_id": 3240, "completion_id": 0, "solution": "class Solution:\n\n    def findMaximumNumber(self, k: int, x: int) -> int:\n        if k == 0:\n            return x\n        if k < 0 or x < 0:\n            return -1\n        if k == 0:\n            return x\n        if k < 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1\n        if k < 0 and x == 0:\n            return -1"}
{"task_id": 3303, "completion_id": 0, "solution": "class Solution:\n\n    def beautifulIndices(self, s: str, a: str, b: str, k: int) -> List[int]:\n        n = len(s)\n        if n == 0:\n            return []\n        if k == 0:\n            return [0]\n        if k == 1:\n            return [0, 1]\n        if k == 2:\n            return [0, 1, 1]\n        if k == 3:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 4:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 5:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 6:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 7:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 8:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 9:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 10:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 11:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 12:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 13:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 14:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 15:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 16:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 17:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 18:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 19:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 20:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 21:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 22:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 23:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 24:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]\n        if k == 25:\n            return [0, 1, 1, 1, 1, 1, 1, 1, 1]"}
{"task_id": 3251, "completion_id": 0, "solution": ""}
{"task_id": 3270, "completion_id": 0, "solution": "class Solution:\n\n    def minMovesToCaptureTheQueen(self, a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n        \"\"\"\n        :type a: int\n        :type b: int\n        :type c: int\n        :type d: int\n        :type e: int\n        :type f: int\n        :rtype: int\n        \"\"\"\n\n        def dfs(x, y, cnt):\n            if x == 0 and y == 0 and (cnt == 0):\n                return 1\n            if x == 0:\n                return 0\n            if y == 0:\n                return 0\n            if cnt == 0:\n                return 0\n            if cnt > 0:\n                return dfs(x - 1, y, cnt - 1) + dfs(x, y - 1, cnt - 1) + dfs(x - 1, y, cnt - 1)\n            return dfs(x, y - 1, cnt - 1) + dfs(x - 1, y, cnt - 1)\n        return dfs(a, b, c) + dfs(a, b, c)"}
{"task_id": 3228, "completion_id": 0, "solution": "class Solution:\n\n    def maximumSetSize(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        s = set(nums1)\n        s.discard(nums2)\n        s.discard(nums2)\n        s.discard(nums2)\n        s.add(0)\n        return max(s)"}
{"task_id": 3233, "completion_id": 0, "solution": "class Solution:\n\n    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n        if k == 0:\n            return 0\n        if k == 1:\n            return 1\n        if s[0] == 'x':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)\n        if s[0] == 'y':\n            return self.maxPartitionsAfterOperations(s[1:], k - 2)\n        if s[0] == 'z':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)\n        if s[0] == 'a':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)\n        if s[0] == 'b':\n            return self.maxPartitionsAfterOperations(s[1:], k - 2)\n        if s[0] == 'c':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)\n        if s[0] == 'd':\n            return self.maxPartitionsAfterOperations(s[1:], k - 2)\n        if s[0] == 'e':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)\n        if s[0] == 'f':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)\n        if s[0] == 'g':\n            return self.maxPartitionsAfterOperations(s[1:], k - 2)\n        if s[0] == 'h':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)\n        if s[0] == 'i':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)\n        if s[0] == 'j':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)\n        if s[0] == 'k':\n            return self.maxPartitionsAfterOperations(s[1:], k - 2)\n        if s[0] == 'l':\n            return self.maxPartitionsAfterOperations(s[1:], k - 1)"}
{"task_id": 3236, "completion_id": 0, "solution": "class Solution:\n\n    def missingInteger(self, nums: List[int]) -> int:\n        \"\"\"\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return i\n        return len(nums) + 1"}
{"task_id": 3249, "completion_id": 0, "solution": "class Solution:\n\n    def minOperations(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        if k == 1:\n            return n\n        if k == 0:\n            return 0\n        if k == n - 1:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[n - 1] == 0:\n            return n - 1\n        if k == 0 and nums[0] == 0:\n            return 0"}
{"task_id": 3239, "completion_id": 0, "solution": "class Solution:\n\n    def minimumOperationsToMakeEqual(self, x: int, y: int) -> int:\n        x_set = set(x)\n        y_set = set(y)\n        if x_set & y_set:\n            return 0\n        if x_set & y_set:\n            return 1\n        return 2\nsol = Solution()"}
{"task_id": 3243, "completion_id": 0, "solution": "class Solution:\n\n    def numberOfPowerfulInt(self, start: int, finish: int, limit: int, s: str) -> int:\n        res = 0\n        for i in range(start, finish + 1):\n            if s.find(i) != s.find(limit - i):\n                res += 1\n        return res"}
{"task_id": 3246, "completion_id": 0, "solution": ""}
{"task_id": 3267, "completion_id": 0, "solution": "class Solution:\n\n    def maximumLength(self, s: str) -> int:\n        \"\"\"\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        dp = [[0] * (len(s) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s) - 1, -1, -1):\n            for j in range(i + 1, len(s) + 1):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n        return dp[0][len(s) - 1]"}
{"task_id": 3266, "completion_id": 0, "solution": ""}
{"task_id": 3203, "completion_id": 0, "solution": "class Solution:\n\n    def canMakePalindromeQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        n = len(s)\n        ans = []\n        for i in range(n):\n            for j in range(i, n):\n                if s[i:j] == s[j:i]:\n                    ans.append(True)\n        for i in range(n):\n            if ans[-1]:\n                ans.pop()\n            else:\n                ans.append(False)\n        return ans"}
{"task_id": 3226, "completion_id": 0, "solution": "class Solution:\n\n    def numberGame(self, nums: List[int]) -> List[int]:\n        if len(nums) == 1:\n            return [nums[0]]\n        arr = [0] * len(nums)\n        for i in range(1, len(nums)):\n            arr[i] = nums[i] + arr[i - 1]\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                arr[i] = 0\n            else:\n                arr[i] = arr[i] + nums[i - 1]\n        return arr"}
{"task_id": 3250, "completion_id": 0, "solution": "class Solution:\n\n    def maximizeSquareArea(self, m: int, n: int, hFences: List[int], vFences: List[int]) -> int:\n        hFences.sort()\n        vFences.sort()\n        area = 0\n        for h in hFences:\n            area += h * (h - 1)\n        for v in vFences:\n            area += v * (v - 1)\n        return area % (10 ** 9 + 7)"}
{"task_id": 3235, "completion_id": 0, "solution": ""}
{"task_id": 3238, "completion_id": 0, "solution": ""}
{"task_id": 3252, "completion_id": 0, "solution": "class Solution:\n\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(n):\n            if nums[i] == 0:\n                count += 1\n            elif nums[i] == 1:\n                count += 1\n            elif nums[i] == 2:\n                count += 1\n            elif nums[i] == 3:\n                count += 1\n            elif nums[i] == 4:\n                count += 1\n            elif nums[i] == 5:\n                count += 1\n            elif nums[i] == 6:\n                count += 1\n            elif nums[i] == 7:\n                count += 1\n            elif nums[i] == 8:\n                count += 1\n            elif nums[i] == 9:\n                count += 1\n            elif nums[i] == 10:\n                count += 1\n            elif nums[i] == 11:\n                count += 1\n            elif nums[i] == 12:\n                count += 1\n            elif nums[i] == 13:\n                count += 1\n            elif nums[i] == 14:\n                count += 1\n            elif nums[i] == 15:\n                count += 1\n            elif nums[i] == 16:\n                count += 1\n            elif nums[i] == 17:\n                count += 1\n            elif nums[i] == 18:\n                count += 1\n            elif nums[i] == 19:\n                count += 1\n            elif nums[i] == 20:\n                count += 1\n            elif nums[i] == 21:\n                count += 1\n            elif nums[i] == 22:\n                count += 1\n            elif nums[i] == 23:\n                count += 1\n            elif nums[i] == 24:\n                count += 1\n            elif nums[i] == 25:\n                count += 1\n            elif nums[i] == 26:\n                count += 1\n            elif nums[i] == 27:\n                count += 1\n            elif nums[i] == 28:\n                count += 1\n            elif nums[i] == 29:\n                count += 1"}
{"task_id": 3262, "completion_id": 0, "solution": "class Solution:\n\n    def largestPerimeter(self, nums: List[int]) -> int:\n        nums.sort()\n        for i in range(len(nums) - 2):\n            if nums[i] + nums[i + 1] > nums[i + 2]:\n                return nums[i] + nums[i + 1] + nums[i + 2]\n        return -1"}
{"task_id": 3248, "completion_id": 0, "solution": "class Solution:\n\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                count += 1\n            else:\n                count = 0\n        return count"}
{"task_id": 3218, "completion_id": 0, "solution": "class Solution:\n\n    def placedCoins(self, edges: List[List[int]], cost: List[int]) -> List[int]:\n        n = len(edges)\n        cost = [0] * n\n\n        def dfs(node, parent, cost):\n            if node == parent:\n                return cost[node]\n            cost[node] = min(cost[node], cost[parent] + dfs(node, node, cost))\n            return cost[node]"}
{"task_id": 3227, "completion_id": 0, "solution": "class Solution:\n\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        n = len(grid)\n        ans = []\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    ans.append(i)\n        return ans"}
{"task_id": 3241, "completion_id": 0, "solution": "class Solution:\n\n    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:\n        if k == 0:\n            return []\n        if k == 1:\n            return [nums]\n        if k == 2:\n            return [nums[0], nums[1]]\n        if k == 3:\n            return [nums[0], nums[1], nums[2]]\n        res = []\n        for num in nums:\n            if num % k == 0:\n                res.append([num, num])\n            else:\n                res.append([num, num])\n        return res"}
{"task_id": 3229, "completion_id": 0, "solution": "class Solution:\n\n    def minimumCost(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] > nums[j]:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + nums[i] + nums[j])\n        return min(dp[0][n - 1])"}
{"task_id": 3196, "completion_id": 0, "solution": "class Solution:\n\n    def maxFrequencyScore(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            res += nums[i] * (n - i)\n        return res"}
{"task_id": 3220, "completion_id": 0, "solution": "class Solution:\n\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        n = len(batteryPercentages)\n        count = 0\n        for i in range(n):\n            if batteryPercentages[i] > 0:\n                count += 1\n        return count"}
{"task_id": 3234, "completion_id": 0, "solution": "class Solution:\n\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        res = []\n        for i in range(len(variables)):\n            if i == 0:\n                res.append(i)\n            else:\n                res.append(self.getGoodIndices(variables[i - 1], target - variables[i - 1][0]) + [i])\n        return res"}
{"task_id": 3213, "completion_id": 0, "solution": "class Solution:\n\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    count += 1\n        return count"}
{"task_id": 3212, "completion_id": 0, "solution": "class Solution:\n\n    def numberOfGoodPartitions(self, nums: List[int]) -> int:\n        count = 0\n        for num in nums:\n            if num > 0:\n                count += 1\n        return count"}
{"task_id": 3206, "completion_id": 0, "solution": "class Solution:\n\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        len1 = len(nums1)\n        len2 = len(nums2)\n        if len1 > len2:\n            return self.findIntersectionValues(nums2, nums1)\n        if len2 > len1:\n            return self.findIntersectionValues(nums1, nums2)\n        p1 = 0\n        p2 = 0\n        ans = []\n        while p1 < len1 and p2 < len2:\n            if nums1[p1] <= nums2[p2]:\n                ans.append(nums1[p1])\n                p1 += 1\n            else:\n                ans.append(nums2[p2])\n                p2 += 1\n        while p1 < len1:\n            ans.append(nums1[p1])\n            p1 += 1\n        while p2 < len2:\n            ans.append(nums2[p2])\n            p2 += 1\n        return ans"}
{"task_id": 3230, "completion_id": 0, "solution": "class Solution:\n\n    def removeAlmostEqualCharacters(self, word: str) -> int:\n        \"\"\"\n        :type word: str\n        :rtype: int\n        \"\"\"\n        if not word:\n            return 0\n        word_len = len(word)\n        word_dict = {}\n        for i in range(word_len):\n            if word[i] not in word_dict:\n                word_dict[word[i]] = 1\n            else:\n                word_dict[word[i]] += 1\n        for i in range(1, word_len):\n            if word[i] not in word_dict:\n                return i\n            elif word[i] in word_dict and word_dict[word[i]] > 1:\n                return i\n        return 0"}
{"task_id": 3225, "completion_id": 0, "solution": "class Solution:\n\n    def maxSubarrayLength(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n == 1:\n            return 1\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1] + nums[i], nums[i])\n        return max(dp)"}
{"task_id": 3217, "completion_id": 0, "solution": "class Solution:\n\n    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n\n        def dfs(i, j):\n            if i == j:\n                return 1\n            if i < j:\n                return 0\n            if i == n - 1:\n                return max(dfs(i + 1, j), dfs(i, j + 1))\n            return dfs(i + 1, j) + dfs(i, j + 1)\n        n = max(n, maxDistance)\n        roads.sort(key=lambda x: x[0])\n        ans = 0\n        for i in range(n):\n            ans += dfs(i, 0)\n        return ans"}
{"task_id": 3221, "completion_id": 0, "solution": "class Solution:\n\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        n = len(mountain)\n        res = []\n        for i in range(n):\n            if mountain[i] > mountain[i + 1]:\n                res.append(i)\n        return res"}
{"task_id": 3231, "completion_id": 0, "solution": "class Solution:\n\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        n = len(coins)\n        dp = [[0] * (target + 1) for _ in range(n + 1)]\n        dp[0][0] = 0\n        for i in range(1, n + 1):\n            for j in range(target + 1):\n                if j >= coins[i - 1]:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - coins[i - 1]] + 1)\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][target]"}
{"task_id": 3223, "completion_id": 0, "solution": "class Solution:\n\n    def countCompleteSubstrings(self, word: str, k: int) -> int:\n        n = len(word)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if word[i - 1] == word[j - 1]:\n                    dp[i] += dp[j]\n                else:\n                    dp[i] = dp[j]\n        return dp[n]"}
{"task_id": 3224, "completion_id": 0, "solution": "class Solution:\n\n    def numberOfSequence(self, n: int, sick: List[int]) -> int:\n        sick = sorted(sick, reverse=True)\n        res = 0\n        for i in range(n):\n            res += sum((sick[i] for i in range(n)))\n        return res"}
{"task_id": 3215, "completion_id": 0, "solution": "class Solution:\n\n    def areSimilar(self, mat: List[List[int]], k: int) -> bool:\n        (m, n) = (len(mat), len(mat[0]))\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    mat[i][j] = 0\n                else:\n                    mat[i][j] = 1\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    mat[i][j] = 0\n                else:\n                    mat[i][j] = 1\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    mat[i][j] = 0\n                else:\n                    mat[i][j] = 1\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    mat[i][j] = 0\n                else:\n                    mat[i][j] = 1\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 1:\n                    mat[i][j] = 0\n                else:\n                    mat[i][j] = 1\n        return mat\nmat = [[1, 2, 1, 2], [5, 5, 5, 5], [6, 3, 6, 3]]\nk = 2\nsol = Solution()"}
{"task_id": 3210, "completion_id": 0, "solution": "class Solution:\n\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [[0] * (k + 1) for _ in range(n)]\n        for i in range(n):\n            dp[i][0] = 1\n            for j in range(1, k + 1):\n                if s[i - j] == s[i - j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return max(dp[n - 1])"}
{"task_id": 3219, "completion_id": 0, "solution": "class Solution:\n\n    def lexicographicallySmallestArray(self, nums: List[int], limit: int) -> List[int]:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return min(nums[0], nums[1])\n        if n == 3:\n            return min(nums[0], nums[1])\n        if n == 4:\n            return min(nums[0], nums[1])\n        if n == 5:\n            return min(nums[0], nums[1])\n        if n == 6:\n            return min(nums[0], nums[1])\n        if n == 7:\n            return min(nums[0], nums[1])\n        if n == 8:\n            return min(nums[0], nums[1])\n        if n == 9:\n            return min(nums[0], nums[1])\n        if n == 10:\n            return min(nums[0], nums[1])\n        if n == 11:\n            return min(nums[0], nums[1])\n        if n == 12:\n            return min(nums[0], nums[1])\n        if n == 13:\n            return min(nums[0], nums[1])\n        if n == 14:\n            return min(nums[0], nums[1])\n        if n == 15:\n            return min(nums[0], nums[1])\n        if n == 16:\n            return min(nums[0], nums[1])\n        if n == 17:\n            return min(nums[0], nums[1])\n        if n == 18:\n            return min(nums[0], nums[1])\n        if n == 19:\n            return min(nums[0], nums[1])\n        if n == 20:\n            return min(nums[0], nums[1])\n        if n == 21:\n            return min(nums[0], nums[1])\n        if n == 22:\n            return min(nums[0], nums[1])\n        if n == 23:\n            return min(nums[0], nums[1])\n        if n == 24:\n            return min(nums[0], nums[1])\n        if n == 25:\n            return min(nums[0], nums[1])\n        if n == 26:\n            return min(nums[0], nums[1])\n        if n == 27:\n            return min(nums[0], nums[1])\n        if n == 28:\n            return min(nums[0], nums[1])"}
{"task_id": 3208, "completion_id": 0, "solution": "class Solution:\n\n    def beautifulSubstrings(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if s[i - 1] == s[j - 1]:\n                    dp[i] += dp[j]\n                else:\n                    dp[i] = dp[j]\n        return dp[n]"}
{"task_id": 3194, "completion_id": 0, "solution": ""}
{"task_id": 3214, "completion_id": 0, "solution": "class Solution:\n\n    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()\n        vBars.sort()\n        hBars.sort()"}
{"task_id": 3209, "completion_id": 0, "solution": "class Solution:\n\n    def minimumCoins(self, prices: List[int]) -> int:\n        n = len(prices)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = prices[i]\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if j == i:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + prices[j])\n                else:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + prices[j])\n        return dp[0][n - 1]"}
{"task_id": 3211, "completion_id": 0, "solution": "class Solution:\n\n    def findMaximumLength(self, nums: List[int]) -> int:\n        max_len = 0\n        for i in range(len(nums)):\n            if nums[i] > nums[i - 1]:\n                max_len = max(max_len, i - i)\n        return max_len"}
{"task_id": 3207, "completion_id": 0, "solution": "class Solution:\n\n    def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n        if not s3:\n            return -1\n        if not s1:\n            return -1\n        if not s2:\n            return -1\n        if not s1 and (not s2):\n            return -1\n        if not s3 and (not s2):\n            return -1\n        if not s1 and (not s2):\n            return -1\n        if not s3 and (not s2):\n            return -1\n        if not s2 and (not s1):\n            return -1\n        if not s3 and (not s2):\n            return -1\n        if not s1 and (not s2):\n            return -1\n        if not s2 and (not s1):\n            return -1\n        if not s3 and (not s2):\n            return -1\n        if not s1 and (not s2):\n            return -1\n        if not s2 and (not s1):\n            return -1\n        if not s3 and (not s2):\n            return -1\n        if not s1 and (not s2):\n            return -1\n        if not s2 and (not s1):\n            return -1\n        if not s3 and (not s2):\n            return -1\n        if not s1 and (not s2):\n            return -1\n        if not s2 and (not s1):\n            return -1\n        if not s3 and (not s2):\n            return -1\n        if not s1 and (not s2):\n            return -1\n        if not s2 and (not s1):\n            return -1\n        if not s3 and (not s2):\n            return -1"}
{"task_id": 3195, "completion_id": 0, "solution": "class Solution:\n\n    def minimumSteps(self, s: str) -> int:\n        n = len(s)\n        ans = 0\n        for i in range(n):\n            if s[i] == '1':\n                ans += 1\n                if i == n - 1:\n                    return ans\n        return ans"}
{"task_id": 3192, "completion_id": 0, "solution": "class Solution:\n\n    def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n        mod = 10 ** 9 + 7\n        ans = 0\n        for i in range(n):\n            ans = (ans + a * b) % mod\n        return ans"}
{"task_id": 3181, "completion_id": 0, "solution": "class Solution:\n\n    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(heights)\n        ans = [-1] * n\n        for i in range(n):\n            ans[i] = -1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if heights[i] > heights[j]:\n                    ans[i] = j\n        for i in range(n):\n            if ans[i] == -1:\n                ans[i] = i\n        return ans"}
{"task_id": 3193, "completion_id": 0, "solution": "class Solution:\n\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        ans = 0\n        for i in range(len(nums) - 1):\n            ans = max(ans, nums[i] + nums[i + 1])\n        return ans"}
{"task_id": 3202, "completion_id": 0, "solution": "class Solution:\n\n    def findHighAccessEmployees(self, access_times: List[List[str]]) -> List[str]:\n        n = len(access_times)\n        ans = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                if access_times[i][0] == access_times[j][0]:\n                    ans.append(j)\n        return ans"}
{"task_id": 3190, "completion_id": 0, "solution": "class Solution:\n\n    def minOperations(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        m = len(nums2)\n        if n == 0 or m == 0:\n            return -1\n        if n == 1:\n            return 0\n        if m == 1:\n            return nums1[0]\n        if m == 2:\n            return min(nums1[0], nums2[0])\n        if m == 3:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 4:\n            return min(nums1[0], nums2[0]) + nums2[1]\n        if m == 5:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 6:\n            return min(nums1[0], nums2[0]) + nums2[1]\n        if m == 7:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 8:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 9:\n            return min(nums1[0], nums2[0]) + nums2[1]\n        if m == 10:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 11:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 12:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 13:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 14:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 15:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 16:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 17:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 18:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 19:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 20:\n            return min(nums1[0], nums2[0]) + nums1[1]\n        if m == 21:\n            return min(nums1[0], nums2[0]) + nums1[1]"}
{"task_id": 3197, "completion_id": 0, "solution": "class Solution:\n\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        nums.sort()\n        ans = 0\n        for i in range(len(nums) - 1):\n            ans = max(ans, nums[i] + nums[i + 1])\n        return ans"}
{"task_id": 3199, "completion_id": 0, "solution": "class Solution:\n\n    def distributeCandies(self, n: int, limit: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 10\n        if n == 4:\n            return 5\n        if n == 5:\n            return 3\n        if n == 6:\n            return 10\n        if n == 7:\n            return 10\n        if n == 8:\n            return 10\n        if n == 9:\n            return 10\n        if n == 10:\n            return 10\n        if n == 11:\n            return 10\n        if n == 12:\n            return 10\n        if n == 13:\n            return 10\n        if n == 14:\n            return 10\n        if n == 15:\n            return 10\n        if n == 16:\n            return 10\n        if n == 17:\n            return 10\n        if n == 18:\n            return 10\n        if n == 19:\n            return 10\n        if n == 20:\n            return 10\n        if n == 21:\n            return 10\n        if n == 22:\n            return 10\n        if n == 23:\n            return 10\n        if n == 24:\n            return 10\n        if n == 25:\n            return 10\n        if n == 26:\n            return 10\n        if n == 27:\n            return 10\n        if n == 28:\n            return 10\n        if n == 29:\n            return 10\n        if n == 30:\n            return 10\n        if n == 31:\n            return 10\n        if n == 32:\n            return 10\n        if n == 33:\n            return 10\n        if n == 34:\n            return 10\n        if n == 35:\n            return 10"}
{"task_id": 3201, "completion_id": 0, "solution": "class Solution:\n\n    def distributeCandies(self, n: int, limit: int) -> int:\n        \"\"\"\n        :type n: int\n        :type limit: int\n        :rtype: int\n        \"\"\"\n        if n == limit:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]"}
{"task_id": 3200, "completion_id": 0, "solution": "class Solution:\n\n    def stringCount(self, n: int) -> int:\n        MOD = 10 ** 9 + 7\n        MOD_INT = 10 ** 9 + 7\n        MOD_INT = MOD\n        MOD_INT = MOD\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT\n        MOD_INT = MOD_INT"}
{"task_id": 3107, "completion_id": 0, "solution": "class Solution:\n\n    def maxSpending(self, values: List[List[int]]) -> int:\n        n = len(values)\n        dp = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if values[i][j] <= values[j][i]:\n                    dp[i] = max(dp[i], dp[j] + values[i][j])\n        return max(dp)"}
{"task_id": 3188, "completion_id": 0, "solution": "class Solution:\n\n    def findChampion(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            return 22\n        if n == 24:\n            return 23\n        if n == 25:\n            return 24\n        if n == 26:\n            return 25\n        if n == 27:\n            return 26\n        if n == 28:\n            return 27\n        if n == 29:\n            return 28"}
{"task_id": 3189, "completion_id": 0, "solution": "class Solution:\n\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(u):\n            if u in graph[u]:\n                return graph[u][u]\n            for v in graph[u]:\n                if v not in graph[v]:\n                    graph[v].append(u)\n                    dfs(v)\n                    graph[u] = graph[u] + graph[v]\n        for u in range(n):\n            if not dfs(u):\n                return -1\n        return len(graph[u])"}
{"task_id": 3191, "completion_id": 0, "solution": "class Solution:\n\n    def maximumScoreAfterOperations(self, edges: List[List[int]], values: List[int]) -> int:\n        n = len(edges)\n        graph = defaultdict(list)\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node):\n            if node in graph:\n                return graph[node]\n            for nei in graph[node]:\n                if nei not in graph:\n                    graph[nei] = []\n                    dfs(nei)\n        dfs(0)\n        ans = 0\n        for i in range(n):\n            ans = max(ans, values[i])\n        return ans"}
{"task_id": 3184, "completion_id": 0, "solution": "class Solution:\n\n    def maxBalancedSubsequenceSum(self, nums: List[int]) -> int:\n\n        def dfs(i, j):\n            if i == j:\n                return 0\n            if i > j:\n                return 1\n            if nums[i] > nums[j]:\n                return dfs(i + 1, j)\n            return dfs(i, j + 1)\n        n = len(nums)\n        dp = [0] * n\n        dp[0] = nums[0]\n        for i in range(1, n):\n            dp[i] = max(dp[i - 1], nums[i])\n        for i in range(n - 2, -1, -1):\n            dp[i] = max(dp[i + 1], nums[i])\n        for i in range(n - 1, -1, -1):\n            dp[i] = max(dp[i + 1], nums[i])\n        return max(dp)"}
{"task_id": 3183, "completion_id": 0, "solution": ""}
{"task_id": 3171, "completion_id": 0, "solution": "class Solution:\n\n    def minSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1 = sum(nums1)\n        sum2 = sum(nums2)\n        sum1_sum = sum1 + sum2\n        sum2_sum = sum2 + sum1\n        sum2_sum = sum2 + sum1\n        sum1_sum = sum1_sum + sum2_sum\n        sum1_sum = sum1_sum - sum2_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum\n        sum2_sum = sum2_sum - sum1_sum"}
{"task_id": 3178, "completion_id": 0, "solution": "class Solution:\n\n    def minIncrementOperations(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n        ans = 0\n        for i in range(n):\n            if nums[i] == k:\n                ans += 1\n                nums[i] = k\n                k -= 1\n        return ans"}
{"task_id": 3179, "completion_id": 0, "solution": "class Solution:\n\n    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -> int:\n        n = len(coins)\n        if k == 0:\n            return 0\n        if k == 1:\n            return max(edges[0])\n        if k == 2:\n            return max(edges[1])\n        if k == 3:\n            return max(edges[0])\n        max_val = 0\n        for i in range(n):\n            max_val = max(max_val, edges[i][1])\n        min_val = 0\n        for i in range(n):\n            min_val = min(min_val, edges[i][0])\n        max_val = max(max_val, edges[n - 1][1])\n        min_val = min(min_val, edges[n - 1][0])\n        max_val = max(max_val, edges[n - 1][2])\n        min_val = min(min_val, edges[n - 1][3])\n        return max(max_val, min_val)"}
{"task_id": 3163, "completion_id": 0, "solution": "class Solution:\n\n    def sumCounts(self, nums: List[int]) -> int:\n        counts = {}\n        for num in nums:\n            if num not in counts:\n                counts[num] = 1\n            else:\n                counts[num] += 1\n        return sum(counts.values())"}
{"task_id": 3174, "completion_id": 0, "solution": "class Solution:\n\n    def minChanges(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if s[i - 1] == s[j - 1]:\n                    dp[i] = dp[j] + dp[i - 1]\n                else:\n                    dp[i] = min(dp[i], dp[j - 1] + 1)\n        return dp[-1]"}
{"task_id": 3106, "completion_id": 0, "solution": "class Solution:\n\n    def lengthOfLongestSubsequence(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"}
{"task_id": 3139, "completion_id": 0, "solution": "class Solution:\n\n    def sumCounts(self, nums: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if nums[i - 1] > nums[i]:\n                    dp[i] = (dp[i] + dp[j]) % mod\n                else:\n                    dp[i] = (dp[i] + dp[j]) % mod\n        return dp[n] % mod"}
{"task_id": 3176, "completion_id": 0, "solution": "class Solution:\n\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return min(nums[0], nums[1])\n        if n == 3:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 4:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 5:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 6:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 7:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 8:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 9:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 10:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 11:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 12:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 13:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 14:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 15:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 16:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 17:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 18:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 19:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 20:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 21:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 22:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 23:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 24:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 25:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 26:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 27:\n            return min(nums[0], nums[1]) + nums[2]"}
{"task_id": 3186, "completion_id": 0, "solution": "class Solution:\n\n    def minimumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return -1\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return min(nums[0], nums[1])\n        if n == 3:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 4:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 5:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 6:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 7:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 8:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 9:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 10:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 11:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 12:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 13:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 14:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 15:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 16:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 17:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 18:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 19:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 20:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 21:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 22:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 23:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 24:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 25:\n            return min(nums[0], nums[1]) + nums[2]\n        if n == 26:\n            return min(nums[0], nums[1]) + nums[2]"}
{"task_id": 3166, "completion_id": 0, "solution": "class Solution:\n\n    def minGroupsForValidAssignment(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 1\n        nums.sort()\n        group = [0] * n\n        for i in range(n):\n            if nums[i] == 0:\n                group[i] = 1\n            elif nums[i] == 1:\n                group[i] = 2\n            elif nums[i] == 2:\n                group[i] = 3\n            elif nums[i] == 3:\n                group[i] = 4\n            elif nums[i] == 4:\n                group[i] = 5\n            elif nums[i] == 5:\n                group[i] = 6\n            elif nums[i] == 6:\n                group[i] = 7\n            elif nums[i] == 7:\n                group[i] = 8\n            elif nums[i] == 8:\n                group[i] = 9\n            elif nums[i] == 9:\n                group[i] = 10\n            elif nums[i] == 10:\n                group[i] = 11\n            elif nums[i] == 11:\n                group[i] = 12\n            elif nums[i] == 12:\n                group[i] = 13\n            elif nums[i] == 13:\n                group[i] = 14\n            elif nums[i] == 14:\n                group[i] = 15\n            elif nums[i] == 15:\n                group[i] = 16\n            elif nums[i] == 16:\n                group[i] = 17\n            elif nums[i] == 17:\n                group[i] = 18\n            elif nums[i] == 18:\n                group[i] = 19\n            elif nums[i] == 19:\n                group[i] = 20\n            elif nums[i] == 20:\n                group[i] = 21"}
{"task_id": 2879, "completion_id": 0, "solution": "class Solution:\n\n    def minimumChanges(self, s: str, k: int) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if s[j] == s[i - 1]:\n                    dp[i] = dp[j] + dp[i - 1]\n                else:\n                    dp[i] = min(dp[i], dp[j] + 1)\n        return dp[n]"}
{"task_id": 3165, "completion_id": 0, "solution": "class Solution:\n\n    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:\n        res = []\n        for i in range(len(nums)):\n            if nums[i] == indexDifference:\n                res.append(i)\n            elif nums[i] < valueDifference:\n                res.append(i)\n        return res"}
{"task_id": 3150, "completion_id": 0, "solution": "class Solution:\n\n    def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\""}
{"task_id": 3170, "completion_id": 0, "solution": "class Solution:\n\n    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:\n        res = []\n        for i in range(len(nums)):\n            if nums[i] == valueDifference:\n                res.append(i)\n        return res"}
{"task_id": 3031, "completion_id": 0, "solution": "class Solution:\n\n    def constructProductMatrix(self, grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                dp[i][j] = grid[i][j]\n                if i == 0:\n                    dp[i][j] = grid[i][j] * 2\n                elif j == 0:\n                    dp[i][j] = grid[i][j] * 3\n                elif i == n - 1:\n                    dp[i][j] = grid[i][j] * 5\n                else:\n                    dp[i][j] = grid[i][j] * 10\n        return dp"}
{"task_id": 3164, "completion_id": 0, "solution": ""}
{"task_id": 3143, "completion_id": 0, "solution": "class Solution:\n\n    def getWordsInLongestSubsequence(self, n: int, words: List[str], groups: List[int]) -> List[str]:\n\n        def get_words(s):\n            words = set(words)\n            if len(s) == 1:\n                return s\n            for i in range(len(s)):\n                if s[i] not in words:\n                    return s[:i]\n            return s\n\n        def get_groups(s):\n            groups = set(groups)\n            if len(s) == 1:\n                return s\n            for i in range(len(s)):\n                if s[i] not in groups:\n                    return s[:i]\n            return s\n\n        def get_words(s):\n            words = set(words)\n            if len(s) == 1:\n                return s\n            for i in range(len(s)):\n                if s[i] not in words:\n                    return s[:i]\n            return s\n\n        def get_groups(s):\n            groups = set(groups)\n            if len(s) == 1:\n                return s\n            for i in range(len(s)):\n                if s[i] not in groups:\n                    return s[:i]\n            return s\n\n        def get_words(s):\n            words = set(words)\n            if len(s) == 1:\n                return s\n            for i in range(len(s)):\n                if s[i] not in words:\n                    return s[:i]\n            return s\n\n        def get_groups(s):\n            groups = set(groups)\n            if len(s) == 1:\n                return s\n            for i in range(len(s)):\n                if s[i] not in groups:\n                    return s[:i]\n            return s"}
{"task_id": 3142, "completion_id": 0, "solution": "class Solution:\n\n    def getWordsInLongestSubsequence(self, n: int, words: List[str], groups: List[int]) -> List[str]:\n\n        def get_words(word):\n            words = set(word)\n            for i in range(len(word)):\n                if word[i] in words:\n                    return word[:i] + words.union(words[:i])\n            return word\n        words = get_words(words)\n        groups = get_groups(groups)\n        return [words[0] for words in groups]\n\n    def get_groups(self, groups):\n        groups = set(groups)\n        return [s[0] for s in groups]\n\n    def get_words(self, words):\n        words = set(words)\n        return [s[0] for s in words]\n\n    def get_words_by_groups(self, groups):\n        groups = set(groups)\n        return [s[0] for s in groups]\n\n    def get_groups_by_words(self, groups):\n        groups = set(groups)\n        return [s[0] for s in groups]\n\n    def get_words_by_groups_by_words(self, groups):\n        groups = set(groups)\n        return [s[0] for s in groups]\n\n    def get_words_by_groups_by_words_by_words(self, groups):\n        groups = set(groups)\n        return [s[0] for s in groups]\n\n    def get_words_by_groups_by_words_by_words(self, groups):\n        groups = set(groups)\n        return [s[0] for s in groups]\n\n    def get_words_by_groups_by_words_by_words(self, groups):\n        groups = set(groups)\n        return [s[0] for s in groups]\n\n    def get_words_by_groups_by_words_by_words(self, groups):\n        groups = set(groups)\n        return [s[0] for s in groups]"}
{"task_id": 3091, "completion_id": 0, "solution": "class Solution:\n\n    def countSubMultisets(self, nums: List[int], l: int, r: int) -> int:\n        mod = 10 ** 9 + 7\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9\n        mod = 10 ** 9 + 9"}
{"task_id": 3172, "completion_id": 0, "solution": "class Solution:\n\n    def differenceOfSums(self, n: int, m: int) -> int:\n        sum_1 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_2 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_3 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_4 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_5 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_6 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_7 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_8 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_9 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_10 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_11 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_12 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_13 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_14 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_15 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_16 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_17 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_18 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_19 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_20 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_21 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_22 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_23 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_24 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_25 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_26 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))\n        sum_27 = sum((num1 * num2 for (num1, num2) in zip(num1, num2)))"}
{"task_id": 3151, "completion_id": 0, "solution": "class Solution:\n\n    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:\n        n = len(processorTime)\n        tasks.sort(key=lambda x: processorTime[x])\n\n        def dfs(i, j, t):\n            if i == n:\n                return 0\n            if i < n and processorTime[i] <= t:\n                return dfs(i + 1, j, t)\n            if j < n and processorTime[j] <= t:\n                return dfs(i, j + 1, t)\n            if i < n and processorTime[i] <= t:\n                return dfs(i + 1, j, t)\n            return 0\n        return dfs(0, 0, 0)"}
{"task_id": 3033, "completion_id": 0, "solution": "class Solution:\n\n    def minOperations(self, s1: str, s2: str, x: int) -> int:\n        n = len(s1)\n        m = len(s2)\n        if n == 0 or m == 0:\n            return -1\n        if x == 0:\n            return 0\n        if x == 1:\n            return n\n        if x == 2:\n            return m\n        if x == 3:\n            return min(m, n)\n        if x == 4:\n            return min(m, n)\n        if x == 5:\n            return min(m, n)\n        if x == 6:\n            return min(m, n)\n        if x == 7:\n            return min(m, n)\n        if x == 8:\n            return min(m, n)\n        if x == 9:\n            return min(m, n)\n        if x == 10:\n            return min(m, n)\n        if x == 11:\n            return min(m, n)\n        if x == 12:\n            return min(m, n)\n        if x == 13:\n            return min(m, n)\n        if x == 14:\n            return min(m, n)\n        if x == 15:\n            return min(m, n)\n        if x == 16:\n            return min(m, n)\n        if x == 17:\n            return min(m, n)\n        if x == 18:\n            return min(m, n)\n        if x == 19:\n            return min(m, n)\n        if x == 20:\n            return min(m, n)\n        if x == 21:\n            return min(m, n)\n        if x == 22:\n            return min(m, n)\n        if x == 23:\n            return min(m, n)\n        if x == 24:\n            return min(m, n)\n        if x == 25:\n            return min(m, n)\n        if x == 26:\n            return min(m, n)\n        if x == 27:\n            return min(m, n)"}
{"task_id": 3153, "completion_id": 0, "solution": "class Solution:\n\n    def maxSum(self, nums: List[int], k: int) -> int:\n        MOD = 10 ** 9 + 7\n        n = len(nums)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[0][0] = nums[0]\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n                if j - 1 >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n                if j - 1 < 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n        return dp[n][k]"}
{"task_id": 3154, "completion_id": 0, "solution": "class Solution:\n\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            if nums[i] > nums[i - 1]:\n                res = max(res, nums[i] + nums[i - 1])\n        return res"}
{"task_id": 3152, "completion_id": 0, "solution": "class Solution:\n\n    def maximumTripletValue(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n < 3:\n            return 0\n        nums.sort()\n        ans = 0\n        for i in range(n - 2):\n            for j in range(i + 1, n):\n                if nums[i] > nums[j]:\n                    ans = max(ans, nums[i] + nums[j])\n        return ans"}
{"task_id": 3141, "completion_id": 0, "solution": "class Solution:\n\n    def minSizeSubarray(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        prefix = [0] * n\n        prefix[0] = nums[0]\n        for i in range(1, n):\n            prefix[i] = prefix[i - 1] + nums[i]\n        res = n\n        for i in range(n):\n            prefix[i] = min(prefix[i - 1], prefix[i])\n        for i in range(n - 1, -1, -1):\n            if prefix[i] == target:\n                res = min(res, i + 1)\n        return res"}
{"task_id": 3140, "completion_id": 0, "solution": "class Solution:\n\n    def countVisitedNodes(self, edges: List[int]) -> List[int]:\n        n = len(edges)\n        visited = [0] * n\n        for i in range(n):\n            visited[i] = 1\n\n        def dfs(node):\n            visited[node] = 1\n            for nei in graph[node]:\n                if visited[nei] == 0:\n                    dfs(nei)\n        for i in range(n):\n            if visited[i] == 0:\n                dfs(i)\n        return [visited[i] for i in range(n)]"}
{"task_id": 3044, "completion_id": 0, "solution": "class Solution:\n\n    def minOperations(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n == 1:\n            return n\n        if k == 1:\n            return n - 1\n        if k == 0:\n            return n - 1\n        if k < 0:\n            return -1\n        sum_ = 0\n        for i in range(n):\n            sum_ += nums[i]\n        sum_ = sum_ - k\n        sum_ = sum_ // k\n        sum_ = sum_ - k * k\n        sum_ = sum_ // k\n        sum_ = sum_ - k * k\n        sum_ = sum_ - k * k * k\n        sum_ = sum_ // k\n        sum_ = sum_ - k * k * k * k\n        sum_ = sum_ - k * k * k * k * k\n        sum_ = sum_ - k * k * k * k * k\n        sum_ = sum_ - k * k * k * k * k\n        sum_ = sum_ - k * k * k * k * k\n        sum_ = sum_ - k * k * k * k * k\n        sum_ = sum_ - k * k * k * k * k\n        sum_ = sum_ - k * k * k * k * k\n        sum_ = sum_ - k * k * k * k * k"}
{"task_id": 3094, "completion_id": 0, "solution": ""}
{"task_id": 3080, "completion_id": 0, "solution": "class Solution:\n\n    def maxSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 1\n        max_sum = 0\n        min_sum = 0\n        for i in range(n):\n            min_sum = min(min_sum, nums[i])\n            max_sum = max(max_sum, nums[i])\n        return max_sum + min_sum"}
{"task_id": 3058, "completion_id": 0, "solution": "class Solution:\n\n    def maxKDivisibleComponents(self, n: int, edges: List[List[int]], values: List[int], k: int) -> int:\n        graph = defaultdict(list)\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(u):\n            if u in graph:\n                return graph[u]\n            for v in graph[u]:\n                if v not in graph:\n                    graph[u] = [v]\n                    dfs(v)\n        res = 0\n        for u in range(n):\n            if values[u] % k == 0:\n                res += dfs(u)\n        return res"}
{"task_id": 3055, "completion_id": 0, "solution": "class Solution:\n\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        ans = ''\n        for i in range(len(s)):\n            if s[i] == '1':\n                ans += '1'\n            else:\n                ans += '0'\n        return ans"}
{"task_id": 3114, "completion_id": 0, "solution": "class Solution:\n\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        maxHeights.sort()\n        res = 0\n        for i in range(1, len(maxHeights)):\n            if maxHeights[i] < maxHeights[i - 1]:\n                res += maxHeights[i]\n            else:\n                res += maxHeights[i]\n        return res"}
{"task_id": 3113, "completion_id": 0, "solution": "class Solution:\n\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        max_heap = []\n        for i in range(len(maxHeights)):\n            max_heap.append(max(maxHeights[i], max_heap[i]))\n        heapq.heapify(max_heap)\n        res = 0\n        for i in range(len(maxHeights)):\n            res += max_heap[i]\n            heapq.heappush(max_heap, max_heap[i])\n        return res"}
{"task_id": 3112, "completion_id": 0, "solution": "class Solution:\n\n    def countPaths(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(u):\n            if u in graph[u]:\n                return graph[u][u]\n            for v in graph[u]:\n                if v not in graph[v]:\n                    graph[v][u] = dfs(v)\n                    return graph[u][u]\n            graph[u] = [v]\n            return graph[u]\n        return dfs(0)"}
{"task_id": 3093, "completion_id": 0, "solution": "class Solution:\n\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            res += nums[i]\n            if k == 0:\n                k -= 1\n            if k == 0:\n                k = 1\n        return res"}
{"task_id": 3104, "completion_id": 0, "solution": "class Solution:\n\n    def countWays(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if nums[0] == nums[1]:\n            return 2\n        if nums[1] == nums[2]:\n            return 2\n        if nums[2] == nums[0]:\n            return 2\n        if nums[3] == nums[1]:\n            return 2\n        if nums[3] == nums[2]:\n            return 2\n        if nums[3] == nums[0]:\n            return 2\n        if nums[4] == nums[1]:\n            return 2\n        if nums[4] == nums[2]:\n            return 2\n        if nums[4] == nums[3]:\n            return 2\n        if nums[4] == nums[3]:\n            return 2\n        if nums[4] == nums[3]:\n            return 2\n        if nums[4] == nums[2]:\n            return 2\n        if nums[4] == nums[1]:\n            return 2\n        if nums[4] == nums[2]:\n            return 2\n        if nums[4] == nums[3]:\n            return 2\n        if nums[4] == nums[2]:\n            return 2\n        if nums[4] == nums[3]:\n            return 2\n        if nums[4] == nums[2]:\n            return 2\n        if nums[4] == nums[3]:\n            return 2\n        if nums[4] == nums[2]:\n            return 2\n        if nums[4] == nums[3]:\n            return 2\n        if nums[4] == nums[2]:\n            return 2\n        if nums[4] == nums[3]:\n            return 2\n        if nums[4] == nums[2]:\n            return 2\n        if nums[4] == nums[2]:\n            return 2\n        if nums[4] == nums[3]:\n            return 2"}
{"task_id": 3095, "completion_id": 0, "solution": "class Solution:\n\n    def maxNumberOfAlloys(self, n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n\n        def get_max_count(i, j):\n            if i == j:\n                return 0\n            if i < j:\n                return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n            return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n\n        def get_max_count(i, j):\n            if i == j:\n                return 0\n            if i < j:\n                return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n            return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n\n        def get_max_count(i, j):\n            if i == j:\n                return 0\n            if i < j:\n                return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n            return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n\n        def get_max_count(i, j):\n            if i == j:\n                return 0\n            if i < j:\n                return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n            return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n\n        def get_max_count(i, j):\n            if i == j:\n                return 0\n            if i < j:\n                return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n            return get_max_count(i + 1, j) + get_max_count(i, j - 1)\n        return get_max_count(0, n)"}
{"task_id": 3047, "completion_id": 0, "solution": "class Solution:\n\n    def maximumSum(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums)\n        dp = [0] * (n + 1)\n        dp[1] = nums[0]\n        dp[2] = max(nums[0], nums[1])\n        for i in range(3, n + 1):\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        return max(dp)"}
{"task_id": 3045, "completion_id": 0, "solution": "class Solution:\n\n    def minimumRightShifts(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        nums.sort()\n        for i in range(n - 1, -1, -1):\n            if nums[i] > nums[i + 1]:\n                (nums[i], nums[i + 1]) = (nums[i + 1], nums[i])\n        for i in range(n - 1, -1, -1):\n            if nums[i] > nums[i + 1]:\n                (nums[i], nums[i + 1]) = (nums[i + 1], nums[i])\n        for i in range(n - 1, -1, -1):\n            if nums[i] > nums[i + 1]:\n                (nums[i], nums[i + 1]) = (nums[i + 1], nums[i])\n        return sum(nums) - 1"}
{"task_id": 3081, "completion_id": 0, "solution": "class Solution:\n\n    def minLengthAfterRemovals(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums.sort()\n        i = 0\n        j = n - 1\n        while i < j:\n            if nums[i] + nums[j] < nums[i]:\n                i += 1\n            elif nums[i] + nums[j] > nums[j]:\n                j -= 1\n            else:\n                i += 1\n        return n - i"}
{"task_id": 2953, "completion_id": 0, "solution": ""}
{"task_id": 3105, "completion_id": 0, "solution": "class Solution:\n\n    def minEdgeReversals(self, n: int, edges: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        for (u, v) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(node):\n            if len(graph[node]) == 1:\n                return 0\n            res = float('inf')\n            for nei in graph[node]:\n                if nei not in graph[nei]:\n                    res = min(res, dfs(nei))\n            return res\n        return dfs(n)"}
{"task_id": 3034, "completion_id": 0, "solution": "class Solution:\n\n    def numberOfPoints(self, nums: List[List[int]]) -> int:\n        nums.sort()\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i][0] == nums[j][0] and nums[i][1] == nums[j][1]:\n                    count += 1\n        return count"}
{"task_id": 3056, "completion_id": 0, "solution": "class Solution:\n\n    def isReachableAtTime(self, sx: int, sy: int, fx: int, fy: int, t: int) -> bool:\n        if t == 0:\n            return True\n        if t == 1:\n            return sx == sx and sy == sy\n        if t == 2:\n            return sx == sx and sy == sy\n        if t == 3:\n            return sx == sx and sy == fy\n        if t == 4:\n            return sx == sx and sy == fy\n        if t == 5:\n            return sx == sx and sy == fy\n        if t == 6:\n            return sx == sx and sy == fy\n        if t == 7:\n            return sx == sx and sy == fy\n        if t == 8:\n            return sx == sx and sy == fy\n        if t == 9:\n            return sx == sx and sy == fy\n        return False\nsol = Solution()"}
{"task_id": 3092, "completion_id": 0, "solution": "class Solution:\n\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        (m, n) = (len(grid), len(grid[0]))\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        return min(dp)"}
{"task_id": 3024, "completion_id": 0, "solution": "class Solution:\n\n    def numberOfWays(self, s: str, t: str, k: int) -> int:\n        if k == 0:\n            return 0\n        if len(s) == 1:\n            return 1\n        if len(t) == 1:\n            return 1\n        if len(s) == 2:\n            return 2\n        if k == 1:\n            return self.numberOfWays(s, t, k - 1)\n        if k == 2:\n            return self.numberOfWays(s, t, k - 2)\n        if s[0] == t[0]:\n            return self.numberOfWays(s[1:], t[1:], k - 1)\n        if s[0] == t[1]:\n            return self.numberOfWays(s[1:], t[1:], k - 2)\n        if s[1] == t[1]:\n            return self.numberOfWays(s[1:], t[1:], k - 1)\n        if s[1] == t[2]:\n            return self.numberOfWays(s[1:], t[1:], k - 2)\n        if s[1] == t[2]:\n            return self.numberOfWays(s[1:], t[1:], k - 1)\n        if s[1] == t[2]:\n            return self.numberOfWays(s[1:], t[1:], k - 2)\n        return self.numberOfWays(s[1:], t[1:], k - 1)"}
{"task_id": 2998, "completion_id": 0, "solution": "class Solution:\n\n    def countSymmetricIntegers(self, low: int, high: int) -> int:\n        if low == high:\n            return 1\n        if low == high and low % 2 == 0:\n            return 2\n        if low % 2 == 0:\n            return self.countSymmetricIntegers(low, high)\n        if high % 2 == 0:\n            return self.countSymmetricIntegers(low, high)\n        return self.countSymmetricIntegers(low, high - 1) + self.countSymmetricIntegers(low, high - 2)"}
{"task_id": 3046, "completion_id": 0, "solution": "class Solution:\n\n    def minimumOperations(self, num: str) -> int:\n        n = len(num)\n        if n == 1:\n            return 0\n        if num[0] == '0':\n            return 0\n        if num[0] == '1':\n            return 0\n        if num[0] == '2':\n            return 0\n        if num[0] == '3':\n            return 0\n        if num[0] == '4':\n            return 0\n        if num[0] == '5':\n            return 0\n        if num[0] == '6':\n            return 0\n        if num[0] == '7':\n            return 0\n        if num[0] == '8':\n            return 0\n        if num[0] == '9':\n            return 0\n        if num[0] == '1':\n            return 0\n        if num[0] == '2':\n            return 0\n        if num[0] == '3':\n            return 0\n        if num[0] == '4':\n            return 0\n        if num[0] == '5':\n            return 0\n        if num[0] == '6':\n            return 0\n        if num[0] == '7':\n            return 0\n        if num[0] == '8':\n            return 0\n        if num[0] == '9':\n            return 0\n        if num[0] == '1':\n            return 0\n        if num[0] == '2':\n            return 0\n        if num[0] == '3':\n            return 0\n        if num[0] == '4':\n            return 0\n        if num[0] == '5':\n            return 0\n        if num[0] == '6':\n            return 0\n        if num[0] == '7':\n            return 0\n        if num[0] == '8':\n            return 0\n        if num[0] == '9':\n            return 0"}
{"task_id": 2915, "completion_id": 0, "solution": "class Solution:\n\n    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:\n        modulo = 10 ** 9 + 7\n        n = len(nums)\n        modulo_sum = 0\n        for i in range(n):\n            modulo_sum += nums[i] % modulo\n            modulo_sum = modulo_sum % modulo\n        return int(modulo_sum)"}
{"task_id": 3079, "completion_id": 0, "solution": "class Solution:\n\n    def minOperationsQueries(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:\n        graph = defaultdict(list)\n        for (u, v, w) in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        def dfs(u):\n            if u not in graph:\n                return -1\n            for v in graph[u]:\n                if v not in graph:\n                    return -1\n                if graph[v][u] == 1:\n                    graph[v].remove(u)\n                    graph[u].remove(v)\n                    dfs(v)\n            return 0\n        ans = []\n        for (u, v, w) in queries:\n            ans.append(dfs(u))\n            ans.append(dfs(v))\n            ans.append(dfs(w))\n        return ans"}
{"task_id": 2999, "completion_id": 0, "solution": "class Solution:\n\n    def canBeEqual(self, s1: str, s2: str) -> bool:\n        s1_dict = {}\n        s2_dict = {}\n        for i in range(len(s1)):\n            s1_dict[s1[i]] = s1_dict.get(s1[i], 0) + 1\n            s2_dict[s2[i]] = s2_dict.get(s2[i], 0) + 1\n        for i in range(len(s2)):\n            if s2[i] not in s1_dict and s2[i] not in s1_dict:\n                return False\n            if s1_dict[s2[i]] == s2_dict[s2[i]]:\n                s1_dict[s2[i]] -= 1\n                s2_dict[s2[i]] -= 1\n            else:\n                s1_dict[s2[i]] -= 1\n                s2_dict[s2[i]] -= 1\n        return True if s1_dict == s2_dict else False"}
{"task_id": 2978, "completion_id": 0, "solution": "class Solution:\n\n    def checkStrings(self, s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                return False\n        return True"}
{"task_id": 2954, "completion_id": 0, "solution": "class Solution:\n\n    def maxSum(self, nums: List[int], m: int, k: int) -> int:\n        if m == 0:\n            return 0\n        if k == 0:\n            return max(nums)\n        if k < m:\n            return self.maxSum(nums[1:], m, k)\n        if k > m:\n            return self.maxSum(nums[:k], m, k - 1)\n        return self.maxSum(nums[:k], m - 1, k - 1)"}
{"task_id": 3057, "completion_id": 0, "solution": "class Solution:\n\n    def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:\n        MOD = 10 ** 9 + 7\n        n = len(s)\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                if s[i - 1] == s[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[n][k] % MOD"}
{"task_id": 3019, "completion_id": 0, "solution": "class Solution:\n\n    def furthestDistanceFromOrigin(self, moves: str) -> int:\n        moves = moves.split('_')\n        n = len(moves)\n        left = 0\n        right = n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if moves[mid] == 'L':\n                left = mid + 1\n            elif moves[mid] == 'R':\n                right = mid - 1\n            else:\n                return mid\n        return left"}
{"task_id": 3026, "completion_id": 0, "solution": "class Solution:\n\n    def minimumPossibleSum(self, n: int, target: int) -> int:\n        MOD = 10 ** 9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, target + 1):\n                if j >= i:\n                    dp[i] = (dp[i] + dp[j]) % MOD\n                else:\n                    dp[i] = (dp[i] + dp[j]) % MOD\n        return dp[n] % MOD"}
{"task_id": 3025, "completion_id": 0, "solution": "class Solution:\n\n    def minOperations(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        nums.sort()\n\n        def find(i):\n            if nums[i] == target:\n                return i\n            if nums[i] > target:\n                return find(i + 1)\n            return find(i + 1) + 1\n        left = find(0)\n        right = find(n - 1)\n        if left == right:\n            return -1\n        if nums[left] == target:\n            return left\n        if nums[right] == target:\n            return right\n        return -1"}
{"task_id": 3032, "completion_id": 0, "solution": "class Solution:\n\n    def getMaxFunctionValue(self, receiver: List[int], k: int) -> int:\n\n        def getMax(x):\n            if x == 0:\n                return 0\n            if x == 1:\n                return 1\n            if x == 2:\n                return 2\n            if x == 3:\n                return 3\n            if x == 4:\n                return 4\n            if x == 5:\n                return 5\n            if x == 6:\n                return 6\n            if x == 7:\n                return 7\n            if x == 8:\n                return 8\n            if x == 9:\n                return 9\n            if x == 10:\n                return 10\n            if x == 11:\n                return 11\n            if x == 12:\n                return 12\n            if x == 13:\n                return 13\n            if x == 14:\n                return 14\n            if x == 15:\n                return 15\n            if x == 16:\n                return 16\n            if x == 17:\n                return 17\n            if x == 18:\n                return 18\n            if x == 19:\n                return 19\n            if x == 20:\n                return 20\n            if x == 21:\n                return 21\n            if x == 22:\n                return 22\n            if x == 23:\n                return 23\n            if x == 24:\n                return 24"}
{"task_id": 2977, "completion_id": 0, "solution": ""}
{"task_id": 2811, "completion_id": 0, "solution": "class Solution:\n\n    def minimumSum(self, n: int, k: int) -> int:\n        \"\"\"\n        Time: O(n^2)\n        Space: O(n)\n        \"\"\"\n        if k == 0:\n            return 0\n        if k == 1:\n            return n\n        if k == 2:\n            return n - k\n        if k == 3:\n            return n - k + k - 1\n        if k == 4:\n            return n - k + k - 2\n        if k == 5:\n            return n - k + k - 3\n        if k == 6:\n            return n - k + k - 4\n        if k == 7:\n            return n - k + k - 5\n        if k == 8:\n            return n - k + k - 6\n        if k == 9:\n            return n - k + k - 7\n        if k == 10:\n            return n - k + k - 8\n        if k == 11:\n            return n - k + k - 9\n        if k == 12:\n            return n - k + k - 10\n        if k == 13:\n            return n - k + k - 11\n        if k == 14:\n            return n - k + k - 12\n        if k == 15:\n            return n - k + k - 13\n        if k == 16:\n            return n - k + k - 14\n        if k == 17:\n            return n - k + k - 15\n        if k == 18:\n            return n - k + k - 15\n        if k == 19:\n            return n - k + k - 16\n        if k == 20:\n            return n - k + k - 17\n        if k == 21:\n            return n - k + k - 16\n        if k == 22:\n            return n - k + k - 17\n        if k == 23:\n            return n - k + k - 16\n        if k == 24:\n            return n - k + k - 17\n        if k == 25:\n            return n - k + k - 16\n        if k == 26:\n            return n - k + k - 17\n        if k == 27:\n            return n - k + k - 16\n        if k == 28:\n            return n - k + k - 17\n        if k == 29:\n            return n - k + k - 16\n        if k == 30:\n            return n - k + k - 17\n        if k == 31:\n            return n - k + k - 16\n        if k == 32:\n            return n - k + k - 17"}
{"task_id": 2979, "completion_id": 0, "solution": "class Solution:\n\n    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:\n        \"\"\"\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - offers[i - 1]] + offers[i - 1][j])\n        return dp[n][n]"}
{"task_id": 2832, "completion_id": 0, "solution": "class Solution:\n\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        if n == 1:\n            return 1\n        if k == 1:\n            return n\n        if k == 2:\n            return n\n        if k == 3:\n            return n - 1\n        if k == 4:\n            return n - 2\n        if k == 5:\n            return n - 3\n        if k == 6:\n            return n - 4\n        if k == 7:\n            return n - 5\n        if k == 8:\n            return n - 6\n        if k == 9:\n            return n - 7\n        if k == 10:\n            return n - 8\n        if k == 11:\n            return n - 9\n        if k == 12:\n            return n - 10\n        if k == 13:\n            return n - 11\n        if k == 14:\n            return n - 12\n        if k == 15:\n            return n - 13\n        if k == 16:\n            return n - 14\n        if k == 17:\n            return n - 15\n        if k == 18:\n            return n - 15\n        if k == 19:\n            return n - 16\n        if k == 20:\n            return n - 17\n        if k == 21:\n            return n - 18\n        if k == 22:\n            return n - 19\n        if k == 23:\n            return n - 20\n        if k == 24:\n            return n - 21\n        if k == 25:\n            return n - 22\n        if k == 26:\n            return n - 23\n        if k == 27:\n            return n - 24\n        if k == 28:\n            return n - 25\n        if k == 29:\n            return n - 26"}
{"task_id": 2917, "completion_id": 0, "solution": "class Solution:\n\n    def countPairs(self, nums: List[int], target: int) -> int:\n        count = 0\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i] + nums[i + 1] > target:\n                break\n            if nums[i] + nums[i + 1] < target:\n                count += 1\n        return count"}
{"task_id": 3018, "completion_id": 0, "solution": "class Solution:\n\n    def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n        if len(str1) != len(str2):\n            return False\n        str1 = list(str1)\n        str2 = list(str2)\n        for i in range(len(str1)):\n            if str1[i] != str2[i]:\n                return False\n        return True"}
{"task_id": 2904, "completion_id": 0, "solution": "class Solution:\n\n    def minimumOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if nums[0] == nums[1] == nums[2] == nums[3]:\n            return 0\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 0\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 1\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 2\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 0\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 1\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 2\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 0\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 1\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 2\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 0\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 1\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 2\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 0\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 1\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 2\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 0\n        if nums[n - 1] == nums[n - 2] == nums[n - 3]:\n            return 1"}
{"task_id": 3017, "completion_id": 0, "solution": "class Solution:\n\n    def numberOfBeautifulIntegers(self, low: int, high: int, k: int) -> int:\n        count = 0\n        while low <= high:\n            count += 1\n            if low % k == 0 and high % k == 0:\n                return count\n            if low % k == 0 and high % k == 0:\n                return count\n            if low % k == 0 and high % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count\n            if high % k == 0 and low % k == 0:\n                return count"}
{"task_id": 2902, "completion_id": 0, "solution": "class Solution:\n\n    def maxSum(self, nums: List[int]) -> int:\n\n        def get_max_sum(nums):\n            max_sum = -1\n            for i in range(len(nums)):\n                if nums[i] > max_sum:\n                    max_sum = nums[i]\n            return max_sum\n        max_sum = get_max_sum(nums)\n        if max_sum == -1:\n            return -1\n        else:\n            return max_sum"}
{"task_id": 2871, "completion_id": 0, "solution": "class ListNode:\n\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return None\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        slow.next = None\n        return head"}
{"task_id": 3000, "completion_id": 0, "solution": "class Solution:\n\n    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        min_diff = float('inf')\n        for i in range(n):\n            diff = abs(nums[i] - x)\n            if diff < min_diff:\n                min_diff = diff\n        return min_diff"}
{"task_id": 3001, "completion_id": 0, "solution": "class Solution:\n\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        \"\"\"\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if k == 1:\n            return max(nums)\n        if k > n:\n            return self.maximumScore(nums, k - 1)\n        max_num = nums[0]\n        for i in range(1, n):\n            if nums[i] > max_num:\n                max_num = nums[i]\n        return max_num"}
{"task_id": 2886, "completion_id": 0, "solution": "class Solution:\n\n    def finalString(self, s: str) -> str:\n        return s[0]"}
{"task_id": 2916, "completion_id": 0, "solution": "class Solution:\n\n    def canSplitArray(self, nums: List[int], m: int) -> bool:\n        if not nums:\n            return False\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == m:\n                    return True\n        return False"}
{"task_id": 2914, "completion_id": 0, "solution": "class Solution:\n\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1])\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j])\n        return dp[n][m]"}
{"task_id": 2894, "completion_id": 0, "solution": "class Solution:\n\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        max_profit = 0\n        for i in range(len(items)):\n            for j in range(i + 1, len(items)):\n                if items[j][0] - items[i][0] > max_profit:\n                    max_profit = items[j][0] - items[i][0]\n        return max_profit"}
{"task_id": 2955, "completion_id": 0, "solution": "class Solution:\n\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        \"\"\"\n        :type purchaseAmount: int\n        :rtype: int\n        \"\"\"\n        if purchaseAmount == 0:\n            return 0\n        if purchaseAmount < 0:\n            return 0\n        if purchaseAmount % 10 == 0:\n            return self.accountBalanceAfterPurchase(purchaseAmount // 10) + self.accountBalanceAfterPurchase(purchaseAmount // 10)\n        return self.accountBalanceAfterPurchase(purchaseAmount) + self.accountBalanceAfterPurchase(purchaseAmount - 1)"}
{"task_id": 2903, "completion_id": 0, "solution": "class ListNode:\n\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n\n    def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head:\n            return head\n        divisors = []\n        while head:\n            divisors.append(head.val)\n            head = head.next\n        divisors.sort(reverse=True)\n        smallest_divisor = None\n        for i in range(len(divisors)):\n            if smallest_divisor is None:\n                smallest_divisor = divisors[i]\n            else:\n                smallest_divisor = divisors[i]\n        smallest_divisor_node = None\n        for i in range(len(divisors)):\n            if smallest_divisor_node is None:\n                smallest_divisor_node = divisors[i]\n            else:\n                smallest_divisor_node = divisors[i]\n        smallest_divisor_node_node = None\n        for i in range(len(divisors)):\n            if smallest_divisor_node is None:\n                smallest_divisor_node = divisors[i]\n            else:\n                smallest_divisor_node = divisors[i]\n        smallest_divisor_node_node = None\n        for i in range(len(divisors)):\n            if smallest_divisor_node is None:\n                smallest_divisor_node = divisors[i]\n            else:\n                smallest_divisor_node = divisors[i]\n        smallest_divisor_node_node = None\n        for i in range(len(divisors)):\n            if smallest_divisor_node is None:\n                smallest_divisor_node = divisors[i]\n            else:\n                smallest_divisor_node = divisors[i]\n        smallest_divisor_node_node = None"}
{"task_id": 2920, "completion_id": 0, "solution": "class Solution:\n\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        nums.sort()\n        ans = 0\n        for i in range(n):\n            if nums[i] == nums[i - 1]:\n                continue\n            ans += 1\n            nums[i] = nums[i - 1]\n        return ans"}
{"task_id": 2952, "completion_id": 0, "solution": "class Solution:\n\n    def minimumTime(self, nums1: List[int], nums2: List[int], x: int) -> int:\n        n = len(nums1)\n        m = len(nums2)\n        if n == 0:\n            return x\n        if m == 0:\n            return -1\n        if x == 0:\n            return 0\n        if x == 1:\n            return nums1[0]\n        if x == 2:\n            return min(nums1[0], nums2[0])\n        if x == 3:\n            return min(nums1[1], nums2[1])\n        if x == 4:\n            return min(nums1[0], nums2[0])\n        if x == 5:\n            return min(nums1[1], nums2[1])\n        if x == 6:\n            return min(nums1[0], nums2[0])\n        if x == 7:\n            return min(nums1[1], nums2[1])\n        if x == 8:\n            return min(nums1[0], nums2[0])\n        if x == 9:\n            return min(nums1[1], nums2[1])\n        if x == 10:\n            return min(nums1[0], nums2[0])\n        if x == 11:\n            return min(nums1[1], nums2[1])\n        if x == 12:\n            return min(nums1[0], nums2[0])\n        if x == 13:\n            return min(nums1[1], nums2[1])\n        if x == 14:\n            return min(nums1[0], nums2[0])\n        if x == 15:\n            return min(nums1[1], nums2[1])\n        if x == 16:\n            return min(nums1[0], nums2[0])\n        if x == 17:\n            return min(nums1[1], nums2[1])\n        if x == 18:\n            return min(nums1[0], nums2[0])\n        if x == 19:\n            return min(nums1[1], nums2[1])\n        if x == 20:\n            return min(nums1[0], nums2[0])\n        if x == 21:\n            return min(nums1[1], nums2[1])\n        if x == 22:\n            return min(nums1[0], nums2[0])\n        if x == 23:\n            return min(nums1[1], nums2[1])\n        if x == 24:\n            return min(nums1[0], nums2[0])\n        if x == 25:\n            return min(nums1[1], nums2[1])\n        if x == 26:\n            return min(nums1[0], nums2[0])\n        if x == 27:\n            return min(nums1[1], nums2[1])"}
{"task_id": 2876, "completion_id": 0, "solution": "class Solution:\n\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        n = len(hours)\n        res = 0\n        for i in range(n):\n            if target - hours[i] >= 0:\n                res += 1\n        return res"}
{"task_id": 2856, "completion_id": 0, "solution": "class Solution:\n\n    def countCompleteSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    count += 1\n        return count"}
{"task_id": 2877, "completion_id": 0, "solution": "class Solution:\n\n    def minimumString(self, a: str, b: str, c: str) -> str:\n        ans = ''\n        for i in range(len(a)):\n            if a[i] == b[i]:\n                ans += c\n            else:\n                ans += a[i]\n        return ans"}
{"task_id": 2921, "completion_id": 0, "solution": "class Solution:\n\n    def countSteppingNumbers(self, low: str, high: str) -> int:\n        mod = 10 ** 9 + 7\n        ans = 0\n        for i in range(len(low)):\n            if low[i] == '1':\n                ans += 1\n            if high[i] == '1':\n                ans += 1\n        return ans % mod"}
{"task_id": 2881, "completion_id": 0, "solution": "class Solution:\n\n    def splitWordsBySeparator(self, words: List[str], separator: str) -> List[str]:\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]\n        words = [word for word in words if word.islower() and word.isupper()]"}
{"task_id": 2872, "completion_id": 0, "solution": "class Solution:\n\n    def maxArrayValue(self, nums: List[int]) -> int:\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        min_value = min(nums)\n        max_value = max(nums)\n        min_value = min(nums)"}
{"task_id": 2919, "completion_id": 0, "solution": "class Solution:\n\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n        \"\"\"\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        groups = [0] * len(usageLimits)\n        groups[0] = 1\n        for i in range(1, len(usageLimits)):\n            groups[i] = max(groups[i - 1], groups[i - 2] + 1)\n        return max(groups)"}
{"task_id": 2905, "completion_id": 0, "solution": "class Solution:\n\n    def countPalindromePaths(self, parent: List[int], s: str) -> int:\n\n        def find(x):\n            if x != parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                parent[rootX] = rootY\n        for i in range(1, len(parent)):\n            if parent[i] == i:\n                union(i, parent[i])\n        for i in range(1, len(parent)):\n            if parent[i] == i:\n                union(i, parent[i])\n        for i in range(len(parent)):\n            if parent[i] == i:\n                union(i, parent[i])\n        for i in range(len(parent)):\n            if parent[i] == i:\n                union(i, parent[i])\n        for i in range(len(parent)):\n            if parent[i] == i:\n                union(i, parent[i])\n        for i in range(len(parent)):\n            if parent[i] == i:\n                union(i, parent[i])\n        for i in range(len(parent)):\n            if parent[i] == i:\n                union(i, parent[i])\n        for i in range(len(parent)):\n            if parent[i] == i:\n                union(i, parent[i])\n        for i in range(len(parent)):\n            if parent[i] == i:\n                union(i, parent[i])"}
{"task_id": 2892, "completion_id": 0, "solution": ""}
{"task_id": 2887, "completion_id": 0, "solution": "class Solution:\n\n    def sortVowels(self, s: str) -> str:\n        vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])\n        s = list(s)\n        (i, j) = (0, len(s) - 1)\n        while i < j:\n            if s[i] not in vowels:\n                i += 1\n            elif s[j] not in vowels:\n                j -= 1\n            else:\n                (s[i], s[j]) = (s[j], s[i])\n                i += 1\n                j -= 1\n        return ''.join(s)"}
{"task_id": 2893, "completion_id": 0, "solution": "class Solution:\n\n    def maxScore(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n        if n == 2:\n            return max(nums[0], nums[1])\n        if n == 3:\n            return max(nums[0], nums[1])\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = nums[0]\n        dp[0][1] = max(nums[0], nums[1])\n        dp[1][0] = nums[1]\n        dp[1][1] = max(nums[1], nums[0])\n        for i in range(2, n + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums[i])\n        return dp[n][n]"}
{"task_id": 2882, "completion_id": 0, "solution": "class Solution:\n\n    def numberOfWays(self, n: int, x: int) -> int:\n        mod = 10 ** 9 + 7\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 5\n        if n == 5:\n            return 6\n        if n == 6:\n            return 7\n        if n == 7:\n            return 8\n        if n == 8:\n            return 9\n        if n == 9:\n            return 10\n        if n == 10:\n            return 11\n        if n == 11:\n            return 12\n        if n == 12:\n            return 13\n        if n == 13:\n            return 14\n        if n == 14:\n            return 15\n        if n == 15:\n            return 16\n        if n == 16:\n            return 17\n        if n == 17:\n            return 18\n        if n == 18:\n            return 19\n        if n == 19:\n            return 20\n        if n == 20:\n            return 21\n        if n == 21:\n            return 22\n        if n == 22:\n            return 23\n        if n == 23:\n            return 24\n        if n == 24:\n            return 25\n        if n == 25:\n            return 26\n        if n == 26:\n            return 27\n        if n == 27:\n            return 28\n        if n == 28:\n            return 29\n        if n == 29:\n            return 30\n        if n == 30:\n            return 31\n        if n == 31:\n            return 32\n        if n == 32:\n            return 33"}
{"task_id": 2844, "completion_id": 0, "solution": "class Solution:\n\n    def sumOfSquares(self, nums: List[int]) -> int:\n        n = len(nums)\n        sum = 0\n        for i in range(n):\n            sum += nums[i] ** 2\n        return sum"}
{"task_id": 2891, "completion_id": 0, "solution": "class Solution:\n\n    def maximumBeauty(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = nums[0]\n        for i in range(1, n + 1):\n            dp[i] = max(dp[i - 1], nums[i - 1] * (i - 1) + dp[i - 1])\n        return max(dp)"}
{"task_id": 2888, "completion_id": 0, "solution": "class Solution:\n\n    def minimumIndex(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return 0\n        n = len(nums)\n        for i in range(n):\n            if nums[i] > nums[i - 1]:\n                return i\n        for i in range(n - 1, -1, -1):\n            if nums[i] > nums[i + 1]:\n                return i\n        return -1"}
{"task_id": 2884, "completion_id": 0, "solution": "class Solution:\n\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        for i in range(len(word)):\n            for j in range(len(forbidden)):\n                if word[i] == forbidden[j]:\n                    if i - j + 1 > len(word):\n                        word[i:j + 1] = word[i:j + 1] + word[i:j + 1]\n        return max(word)"}
{"task_id": 2812, "completion_id": 0, "solution": "class Solution:\n\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\n        if t == 1:\n            return num\n        if t == 2:\n            return num * 2\n        if t == 3:\n            return num * 3\n        if t == 4:\n            return num * 4\n        if t == 5:\n            return num * 5\n        if t == 6:\n            return num * 6\n        if t == 7:\n            return num * 7\n        if t == 8:\n            return num * 8\n        if t == 9:\n            return num * 9\n        if t == 10:\n            return num * 10\n        if t == 11:\n            return num * 11\n        if t == 12:\n            return num * 12\n        if t == 13:\n            return num * 13\n        if t == 14:\n            return num * 14\n        if t == 15:\n            return num * 15\n        if t == 16:\n            return num * 16\n        if t == 17:\n            return num * 17\n        if t == 18:\n            return num * 18\n        if t == 19:\n            return num * 19\n        if t == 20:\n            return num * 20\n        if t == 21:\n            return num * 21\n        if t == 22:\n            return num * 22\n        if t == 23:\n            return num * 23\n        if t == 24:\n            return num * 24\n        if t == 25:\n            return num * 25\n        if t == 26:\n            return num * 26\n        if t == 27:\n            return num * 27\n        if t == 28:\n            return num * 28\n        if t == 29:\n            return num * 29\n        if t == 30:\n            return num * 30\n        if t == 31:\n            return num * 31\n        if t == 32:\n            return num * 32"}
{"task_id": 2855, "completion_id": 0, "solution": "class Solution:\n\n    def maximumJumps(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1 if nums[0] == 0 else -1\n        if target < nums[0] or target > nums[-1]:\n            return -1\n        dp = [[[0 for i in range(n)] for j in range(n)] for k in range(n)]\n        for i in range(n):\n            dp[i][i] = [0 for i in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j][1] = 1\n                else:\n                    dp[i][j][1] = max(dp[i][j][1], dp[i][j - 1][0] + 1)\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j][2] = 1\n                else:\n                    dp[i][j][2] = max(dp[i][j][2], dp[i + 1][j + 1][0] + 1)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j][3] = 1\n                else:\n                    dp[i][j][3] = max(dp[i][j][3], dp[i + 1][j][0] + 1)\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                if nums[i] == nums[j]:\n                    dp[i][j][4] = 1\n                else:\n                    dp[i][j][4] = max(dp[i][j][4], dp[i + 1][j + 1][0] + 1)"}
{"task_id": 2869, "completion_id": 0, "solution": "class Solution:\n\n    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if nums1[i - 1] > nums2[j]:\n                    dp[i] = max(dp[i], 1 + dp[j])\n        return max(dp)"}
{"task_id": 2878, "completion_id": 0, "solution": "class Solution:\n\n    def checkArray(self, nums: List[int], k: int) -> bool:\n        if len(nums) == 1:\n            return True\n        for i in range(len(nums)):\n            if nums[i] == k:\n                return True\n        return False"}
{"task_id": 2870, "completion_id": 0, "solution": "class Solution:\n\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 2\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        dp[2] = 2\n        dp[3] = 4\n        for i in range(4, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n        return max(dp)"}
{"task_id": 2834, "completion_id": 0, "solution": "class Solution:\n\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        m = len(nums)\n        n = len(moveFrom)\n        res = [0] * n\n        for i in range(m):\n            res[i] = moveFrom[i] + nums[i]\n        for i in range(n):\n            res[i] = moveTo[i] + nums[i]\n        return res"}
{"task_id": 2883, "completion_id": 0, "solution": ""}
{"task_id": 2889, "completion_id": 0, "solution": ""}
{"task_id": 2866, "completion_id": 0, "solution": "class Solution:\n\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            for j in range(i):\n                if nums[i - 1] % 2 == 0 and nums[j] % 2 == 0:\n                    dp[i] = max(dp[i], dp[j] + 1)\n                elif nums[i - 1] % 2 == 0 and nums[j] % 2 == 0:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"}
{"task_id": 2873, "completion_id": 0, "solution": "class Solution:\n\n    def findPrimePairs(self, n: int) -> List[List[int]]:\n        prime_pairs = []\n        for i in range(2, n + 1):\n            if not prime_pairs or prime_pairs[-1] < prime_pairs[-2]:\n                prime_pairs.append([i, prime_pairs[-1]])\n            elif prime_pairs[-1] == prime_pairs[-2]:\n                prime_pairs.append([i, prime_pairs[-1]])\n        return prime_pairs"}
{"task_id": 2868, "completion_id": 0, "solution": "class Solution:\n\n    def continuousSubarrays(self, nums: List[int]) -> int:\n        count = 0\n        for i in range(len(nums)):\n            count += nums[i]\n            if count >= 2:\n                count -= 1\n            else:\n                count = 0\n        return count"}
{"task_id": 2849, "completion_id": 0, "solution": ""}
